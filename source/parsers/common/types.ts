import { AbstractTokenStream } from './AbstractTokenStream';
import { Callback } from '../../system/types';
import { ISyntaxNode, ISyntaxTree } from './syntax';
import { IToken } from '../../tokenizer/types';

/**
 * @internal
 */
type Match = string | RegExp | (RegExp | string)[];

/**
 * A syntax node or syntax tree object.
 */
export type ParsedSyntax = ISyntaxNode | ISyntaxTree;

/**
 * A function which receives an AbstractTokenStream subclass instance
 * as its argument.
 */
export type TokenStreamHandler<P extends ParsedSyntax> = Callback<AbstractTokenStream<P>>;

/**
 * @todo @description
 */
export type TokenMatcher<P extends ParsedSyntax> = [Match, TokenStreamHandler<P>];

/**
 * An object which contains both a parsed syntax object from a token
 * stream, and the final token evaluated by the parser which derived
 * it.
 */
export interface IParserReturn<P extends ParsedSyntax> {
  parsed: Readonly<P>;
  token: IToken;
}

/**
 * A function which receives a single token and returns a parser
 * return object based on subsequent token stream.
 *
 * Parser functions can be generated by createParser(), which allows
 * token matchers to be provided in a configuration object to control
 * stream behavior when an incoming token has a match.
 */
export type Parser<P extends ParsedSyntax> = Callback<IToken, IParserReturn<P>>;
