import { AbstractTokenStream } from './AbstractTokenStream';
import { Callback } from '../../system/types';
import { ISyntaxNode, ISyntaxTree } from './syntax';
import { IToken } from '../../tokenizer/types';

/**
 * A matchable string, regex pattern, or array of strings/regexes for
 * matching token values in a token stream during parsing.
 *
 * @internal
 */
type Match = string | RegExp | Array<RegExp | string>;

/**
 * A syntax node or syntax tree object.
 */
export type ParsedSyntax = ISyntaxNode | ISyntaxTree;

/**
 * A function which receives an AbstractTokenStream subclass instance
 * as its argument.
 */
export type TokenStreamHandler<P extends ParsedSyntax> = Callback<AbstractTokenStream<P>>;

/**
 * A 2-tuple which contains a matchable string, regex, or array of
 * strings/regexes in the first slot, and a handler function in the
 * second to determine what to do in the event that the matchable
 * value(s) are encountered in a token stream.
 */
export type TokenMatcher<P extends ParsedSyntax> = [Match, TokenStreamHandler<P>];

/**
 * An object which contains both a parsed syntax object and the final
 * token evaluated by the parser which derived it. Enforcing that both
 * values are returned together allows a baton-passing approach to parsing,
 * where parent parsers can temporarily defer to child parsers to process
 * a subset of their token stream, and then receive the token from which
 * to continue parsing on top of the parsed syntax object.
 */
export interface IParserReturn<P extends ParsedSyntax> {
  parsed: Readonly<P>;
  token: IToken;
}

/**
 * A function which receives a single token, streams through the following
 * tokens, and returns a parser return object if successful; otherwise the
 * parser halts and throws an error.
 *
 * Parser functions can be generated by createParser(), which allows
 * token matchers to be provided in a configuration object to control
 * behavior upon matching specific incoming tokens.
 */
export type Parser<P extends ParsedSyntax> = Callback<IToken, IParserReturn<P>>;
